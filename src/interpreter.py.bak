"""Main Tubular interpreter implementation.
This module handles the execution loop and all pipe operators.
"""
from typing import List, Tuple, Optional
from collections import deque
from .grid import Grid
from .droplet import Droplet, Direction


class TubularInterpreter:
    """
    The main Tubular interpreter that executes programs on a grid.
    """
    
    def __init__(self, grid: Grid):
        """
        Initialize the interpreter with a grid.
        
        Args:
            grid: The grid representing the Tubular program
        """
        self.grid = grid
        self.droplets: List[Droplet] = []
        self.tick_count = 0
        
        # Initialize the data stack
        self.data_stack: List[int] = []
        
        # Initialize the call stack
        self.call_stack: List[Tuple[int, int, Direction]] = []  # (x, y, direction)
        
        # For output handling
        self.output_buffer = []
        self.ascii_mode = False  # Whether we're in ASCII output mode
        
    def add_droplet(self, x: int, y: int, droplet: Droplet) -> bool:
        """
        Add a droplet at position (x, y) to the simulation.
        Prevents collisions by checking if a droplet already exists at that position.
        
        Args:
            x: X coordinate
            y: Y coordinate
            droplet: The droplet to add
            
        Returns:
            True if the droplet was added, False if there was a collision
        """
        # Check for collisions with existing droplets
        for existing_droplet_pos in [(d.x, d.y) for d in self.droplets]:
            if (x, y) == existing_droplet_pos:
                return False  # Collision - don't add the droplet
        
        # Attach coordinates to the droplet for tracking purposes
        droplet.x = x
        droplet.y = y
        self.droplets.append(droplet)
        return True
    
    def execute_program(self, max_ticks: int = 10000) -> str:
        """
        Execute the Tubular program until completion or max_ticks reached.
        
        Args:
            max_ticks: Maximum number of ticks to execute before stopping
            
        Returns:
            The output of the program
        """
        # Add the initial droplet at the start position
        start_x, start_y = self.grid.start_pos
        initial_droplet = Droplet(value=0, direction=Direction.DOWN)
        self.add_droplet(start_x, start_y, initial_droplet)
        
        while self.droplets and self.tick_count < max_ticks:
            self.tick()
            self.tick_count += 1
            
            # Prevent infinite loops by setting a maximum execution time
            if self.tick_count >= max_ticks:
                print(f"Execution stopped after {max_ticks} ticks to prevent infinite loop")
                break
        
        return "".join(self.output_buffer)
    
    def tick(self):
        """
        Execute one tick of the simulation.
        Each droplet moves one cell in its current direction.
        """
        # Store new droplets created during this tick to avoid modifying the list during iteration
        new_droplets = []
        
        # Process each droplet
        for droplet in self.droplets[:]:  # Create a copy to iterate over
            old_x, old_y = droplet.x, droplet.y
            
            # Calculate new position based on direction
            dy, dx = droplet.move()
            new_x = droplet.x + dx
            new_y = droplet.y + dy
            
            # Update droplet position
            droplet.x = new_x
            droplet.y = new_y
            
            # Get the character at the new position
            char = self.grid.get_cell(new_x, new_y)
            
            # Process the character according to the specification
            if char == " ":
                # Droplet moves into empty space - it's destroyed
                self.droplets.remove(droplet)
            else:
                # Process the pipe operator
                result = self._process_char(droplet, char, new_x, new_y)
                
                if result is False:
                    # Droplet was destroyed by the operator
                    if droplet in self.droplets:
                        self.droplets.remove(droplet)
                elif isinstance(result, Droplet):
                    # The droplet was replaced by a new one
                    if droplet in self.droplets:
                        self.droplets.remove(droplet)
                    # Add the new droplet if no collision
                    if not self.add_droplet(new_x, new_y, result):
                        # Collision occurred, destroy the new droplet
                        pass
                elif isinstance(result, list):
                    # Multiple new droplets were created
                    if droplet in self.droplets:
                        self.droplets.remove(droplet)
                    
                    for new_droplet in result:
                        # Add each new droplet if no collision
                        if not self.add_droplet(new_x, new_y, new_droplet):
                            # Collision occurred, destroy the new droplet
                            pass
                else:
                    # Continue with the same droplet
                    # Update position in case it was changed
                    pass
    
    def _process_char(self, droplet: Droplet, char: str, x: int, y: int) -> Optional[Droplet]:
        """
        Process a character in the grid and apply its effect to the droplet.
        
        Args:
            droplet: The droplet entering the cell
            char: The character in the cell
            x: X coordinate of the cell
            y: Y coordinate of the cell
            
        Returns:
            Either False (droplet destroyed), a new droplet (replacing the old),
            a list of new droplets, or None (continue with same droplet).
        """
        if char == "|":
            # Vertical Pipe: No change in behavior based on entry direction
            # Droplet just continues in its current direction
            return None
        elif char == "-":
            # Horizontal Pipe: No change in behavior based on entry direction
            # Droplet just continues in its current direction
            return None
        elif char == "^":
            # Go Up Pipe: Any droplet entering this pipe has its direction changed to Up
            droplet.change_direction(Direction.UP)
            return None
        elif char == "#":
            # Wall: Stops droplet's movement, effectively destroying it
            return False
        elif char == "/":
            # Forward-Slash Corner
            if droplet.direction == Direction.UP:
                # Conditional Branch: If droplet value is 0, direction becomes Left. 
                # If non-zero, direction becomes Right.
                if droplet.value == 0:
                    droplet.change_direction(Direction.LEFT)
                else:
                    droplet.change_direction(Direction.RIGHT)
            elif droplet.direction == Direction.DOWN:
                # Conditional Branch: If droplet value is 0, direction becomes Right. 
                # If non-zero, direction becomes Left.
                if droplet.value == 0:
                    droplet.change_direction(Direction.RIGHT)
                else:
                    droplet.change_direction(Direction.LEFT)
            elif droplet.direction == Direction.LEFT:
                # Redirects Up
                droplet.change_direction(Direction.UP)
            elif droplet.direction == Direction.RIGHT:
                # Redirects Down
                droplet.change_direction(Direction.DOWN)
            return None
        elif char == "\\":
            # Back-Slash Corner
            if droplet.direction == Direction.UP:
                # Conditional Branch: If droplet value is 0, direction becomes Right.
                # If non-zero, direction becomes Left.
                if droplet.value == 0:
                    droplet.change_direction(Direction.RIGHT)
                else:
                    droplet.change_direction(Direction.LEFT)
            elif droplet.direction == Direction.DOWN:
                # Conditional Branch: If droplet value is 0, direction becomes Left.
                # If non-zero, direction becomes Right.
                if droplet.value == 0:
                    droplet.change_direction(Direction.LEFT)
                else:
                    droplet.change_direction(Direction.RIGHT)
            elif droplet.direction == Direction.LEFT:
                # Redirects Down
                droplet.change_direction(Direction.DOWN)
            elif droplet.direction == Direction.RIGHT:
                # Redirects Up
                droplet.change_direction(Direction.UP)
            return None
        elif char.isdigit():
            # Number Source: When a droplet hits a number character, that character emits 
            # a new droplet downwards with the corresponding integer value. 
            # The original droplet is destroyed.
            new_droplet = Droplet(value=int(char), direction=Direction.DOWN)
            return new_droplet
        elif char == "@":
            # Program Start: This should only happen at the beginning, 
            # but if a droplet somehow returns here, it just continues
            return None
        elif char == ">":
            # Tape Reader: When a droplet hits this character, it begins reading all 
            # adjacent characters to its right until it hits a whitespace or a pipe character.
            # For each character read, it emits a new droplet downwards containing that 
            # character's ASCII value. The original droplet is destroyed.
            # These new droplets should be treated as ASCII when they reach the output sink (!)
            new_droplets = []
            read_x = x + 1
            
            while True:
                next_char = self.grid.get_cell(read_x, y)
                # Stop reading if we encounter a pipe character or whitespace
                if next_char in " @|^-\\/#+"\ or next_char.isspace():

                    break
                # Add the ASCII value of the character as a new droplet with ASCII output flag
                new_droplet = Droplet(value=ord(next_char), direction=Direction.DOWN, is_ascii_output=True)
                new_droplets.append(new_droplet)
                read_x += 1
            
            return new_droplets
        elif char == "?":
            # Character Input: Halts execution and waits for user input.
            # For now, we'll read a single character from stdin and set the droplet's value
            # to its ASCII code. On EOF, set to -1.
            try:
                user_input = input("Enter a character: ")
                if user_input:
                    droplet.value = ord(user_input[0])
                else:
                    droplet.value = -1
            except EOFError:
                droplet.value = -1
            return None
        elif char == "!":
            # Output Sink: Consumes any droplet that enters it.
            # If the droplet was created by a Tape Reader, interpret as ASCII.
            # Otherwise, print the integer value followed by a newline.
            # The issue is we need to track if a droplet was created by a tape reader
            # We'll need to modify the Droplet class to track this
            
            # For now, we'll implement a solution by tracking ASCII mode differently
            # When a droplet is created by `>`, it should have ASCII output behavior
            # Let's add a flag to the droplet to track if it came from a tape reader
            # We need to modify the Droplet class to include this flag
            # But for now, let's just fix the tape reader implementation first
            # Actually, we need to track this somehow. Let me just modify the droplet class inline approach
            # Actually, I'll update the Droplet class in droplet.py to include an ASCII_output flag
            # But for now, we'll modify the processing of the tape reader to return special droplets
            # Let's track this differently using a more sophisticated approach
            
            # The current problem is that we need to know if a droplet was created by `>`
            # Let me add an attribute to droplets to track this:
            is_ascii_output = getattr(droplet, 'is_ascii_output', False)
            
            if is_ascii_output:
                self.output_buffer.append(chr(droplet.value))
            else:
                # Output integer value followed by newline
                self.output_buffer.append(f"{droplet.value}\n")
            return False  # Droplet is consumed
        elif char == "+":
            # Increment: Adds 1 to the droplet's value
            droplet.value += 1
            return None
        elif char == "~":
            # Decrement: Subtracts 1 from the droplet's value
            droplet.value -= 1
            return None
        elif char == ":":
            # Push: The droplet's current value is pushed onto the data stack.
            # The droplet passes through unchanged.
            self.data_stack.append(droplet.value)
            return None
        elif char == ";":
            # Pop: A value is popped from the data stack.
            # The droplet's value is replaced with the popped value.
            # If the stack is empty, the droplet's value becomes 0.
            if self.data_stack:
                droplet.value = self.data_stack.pop()
            else:
                droplet.value = 0
            return None
        elif char == "d":
            # Duplicate: Pushes a copy of the droplet's current value onto the data stack.
            # The droplet passes through unchanged.
            self.data_stack.append(droplet.value)
            return None
        elif char == "A":
            # Add: Pops two values (a and b) from the data stack, calculates b + a,
            # and pushes the result back onto the stack. The droplet is destroyed.
            if len(self.data_stack) >= 2:
                a = self.data_stack.pop()
                b = self.data_stack.pop()
                result = b + a
                self.data_stack.append(result)
            return False  # Droplet is destroyed
        elif char == "S":
            # Subtract: Pops two values (a and b) from the data stack, calculates b - a,
            # and pushes the result back onto the stack. The droplet is destroyed.
            if len(self.data_stack) >= 2:
                a = self.data_stack.pop()
                b = self.data_stack.pop()
                result = b - a
                self.data_stack.append(result)
            return False  # Droplet is destroyed
        elif char == "M":
            # Multiply: Pops two values (a and b) from the data stack, calculates b * a,
            # and pushes the result back onto the stack. The droplet is destroyed.
            if len(self.data_stack) >= 2:
                a = self.data_stack.pop()
                b = self.data_stack.pop()
                result = b * a
                self.data_stack.append(result)
            return False  # Droplet is destroyed
        elif char == "D":
            # Divide: Pops two values (a and b) from the data stack, calculates b / a,
            # and pushes the result back onto the stack. The droplet is destroyed.
            if len(self.data_stack) >= 2:
                a = self.data_stack.pop()
                b = self.data_stack.pop()
                # Integer division
                if a != 0:
                    result = b // a
                else:
                    result = 0  # Avoid division by zero, set to 0 as a default
                self.data_stack.append(result)
            return False  # Droplet is destroyed
        elif char == "G":
            # Get: Pops a y then an x coordinate from the data stack.
            # Reads the value from The Reservoir at (x, y) and pushes it onto the data stack.
            if len(self.data_stack) >= 2:
                y = self.data_stack.pop()
                x = self.data_stack.pop()
                value = self.grid.get_reservoir_value(x, y)
                self.data_stack.append(value)
            return False  # Droplet is destroyed
        elif char == "P":
            # Put: Pops a y, an x, and a value from the data stack.
            # Writes the value to The Reservoir at (x, y).
            if len(self.data_stack) >= 3:
                y = self.data_stack.pop()
                x = self.data_stack.pop()
                value = self.data_stack.pop()
                self.grid.set_reservoir_value(x, y, value)
            return False  # Droplet is destroyed
        elif char == "C":
            # Call: Pops a y then an x coordinate from the data stack.
            # Pushes the current droplet's position and direction onto the call stack.
            # The droplet is then transported to the new (x, y) coordinates.
            if len(self.data_stack) >= 2:
                y = self.data_stack.pop()
                x = self.data_stack.pop()
                # Save current position and direction to call stack
                self.call_stack.append((droplet.x, droplet.y, droplet.direction))
                # Move the droplet to the new position
                droplet.x = x
                droplet.y = y
            return None
        elif char == "R":
            # Return: Pops a position and direction from the call stack.
            # The current droplet is destroyed, and a new one is created at the return location,
            # moving in the stored direction.
            if self.call_stack:
                x, y, direction = self.call_stack.pop()
                new_droplet = Droplet(value=droplet.value, direction=direction)
                # Update the current droplet to the new state
                droplet.value = new_droplet.value
                droplet.direction = new_droplet.direction
                droplet.x = x
                droplet.y = y
            else:
                # If the call stack is empty, just destroy the droplet
                return False
            return None
        else:
            # Unknown character - treat as empty space, destroy droplet
            return False
